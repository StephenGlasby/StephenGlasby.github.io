/*
  Consider the tensor algebra T(V) where V=F^d is finite dimensional vector
  space over F. Let L(V) be the graded free Lie algebra L(V) generated by V
  with Lie bracket [x,y]=x*y-y*x. Let gamma^{n+1}(L(V)) = bigoplus_{i>n} L^i(V)
  where L^i(V)=T^i(V)\cap L(V) is the ith homogeneous component of L(V).
  Then L(V)/gamma^{n+1}(L(V)) is a relatively free graded nilpotent Lie
  algebra over F. If char(F)=p>n, then by the Lazard correspondence there
  is a nilpotent p-group, which we call Gamma_{d,p,n}, having the same order
  and the same class. The code below constructs a Lie n-tuple multiplication
  rule for Gamma_{d,p,n} when n=4. We use the left-normed BCH formula
    x+y+(1/2)[x,y]-(1/12)[x,y,x]+(1/12)[x,y,y]-(1/24)[x,y,x,y].
  Write a Lie element x in the form x = x1+(1/2)x2+(1/12)x3+(1/24)x4 where
  xi \in L^i(V) and we identify this Lie element with the element
  (x1,x2,x3,x4) in the group Gamma_{d,p,n}. If y = y1+(1/2)y2+(1/12)y3+(1/24)y4
  corresponds to (y1,y2,y3,y4), then the above BCH formula gives the formula
   (x1,x2,x3,x4)(y1,y2,y3,y4)=(x1+y1,x2+y2+[x1,x2],
      x3+y3+3[x1,y2]+3[x2,y1]-[x1,y1,x1]+[x1,y1,y1],
      x4+y4+[x1,y3]+3[x2,y2]+[x3,y1]
        +[x2,y1,-x1+y1]+[x1,y2,-x1+y1]+[x1,y1,-x2+y2]-[x1,y1,x1,y1])

  I determined the Lie n-tuple multiplication rules by hand and used Magma
  to check that associtivity holds. Note that associativity is guaranteed to
  hold if char(F)=p>n by Lazard. We show that it holds even without this
  restriction!  
*/

L2:=function(g1,g2) return g1*g2-g2*g1;end function;//Lie bracket on FreeAlgebra
L3:=function(g1,g2,g3) return L2(L2(g1,g2),g3);end function; 
L4:=function(g1,g2,g3,g4) return L2(L3(g1,g2,g3),g4);end function;
L5:=function(g1,g2,g3,g4,g5) return L2(L4(g1,g2,g3,g4),g5);end function;
L:=function(g) if #g eq 1 then return g[1];end if;// L = LEFT normed commutator
  if #g eq 2 then return L2(g[1],g[2]);end if;
  return L2($$(Prune(g)),g[#g]);end function;
R:=function(g) if #g eq 1 then return g[1];end if;// R = RIGHT normed commutator
  if #g eq 2 then return L2(g[1],g[2]);end if;
  return L2(g[1],$$(Reverse(Prune(Reverse(g)))));end function;

//***********************************************************************

A<x1,x2,x3,x4,x5,y1,y2,y3,y4,y5,z1,z2,z3,z4,z5,w1,w2,w3,w4,w5>
  :=FreeAlgebra(Rationals(),20);

M2:=function(x,y)
  local x1,x2,y1,y2;
  x1:=x[1];x2:=x[2];y1:=y[1];y2:=y[2];return <x1+y1,x2+y2+L2(x1,y1)>;
end function;

M3:=function(x,y)
  local x1,x2,x3,y1,y2,y3;
  x1:=x[1];x2:=x[2];x3:=x[3];y1:=y[1];y2:=y[2];y3:=y[3];
  return <x1+y1,x2+y2+L2(x1,y1),
    x3+y3+3*L2(x1,y2)+3*L2(x2,y1)-L3(x1,y1,x1)+L3(x1,y1,y1)>;
end function;

M4:=function(x,y)
  local x1,x2,x3,x4,y1,y2,y3,y4;
  x1:=x[1];x2:=x[2];x3:=x[3];x4:=x[4];y1:=y[1];y2:=y[2];y3:=y[3];y4:=y[4];
  return <x1+y1,x2+y2+L2(x1,y1),
    x3+y3+3*L2(x1,y2)+3*L2(x2,y1)-L3(x1,y1,x1)+L3(x1,y1,y1),
    x4+y4+L2(x1,y3)+3*L2(x2,y2)+L2(x3,y1)
      +L3(x2,y1,-x1+y1)+L3(x1,y2,-x1+y1)+L3(x1,y1,-x2+y2)-L4(x1,y1,x1,y1)>;
end function;

_inv:=function(x)
/*
  Input : x = <x1,...,xn> in Gamma_{p,d,n}
  Output: the inverse element x^-1=<-x1,...,-xn> in Gamma_{p,d,n}
  Remark: assumes V=F^d where char(F) > n 
*/
  local i;
  return <-x[i]: i in [1..#x]>;
end function;

_comm:=function(x,y,M)
/*
  Input : x,y in Gamma_{p,d,n}, M is the multiplication rule for Gamma_{p,d,n}
  Output: the commutator [x,y]=x^-1*y^-1*x*y in G_2(V)
  Remark: assumes V=F^d where char(F) > n
*/
  return M(_inv(x),M(_inv(y),M(x,y)));
end function;

x:=<x1,x2>;y:=<y1,y2>;z:=<z1,z2>;M:=M2;
print "Associative law in G2 is",M(M(x,y),z) eq M(x,M(y,z));
print "Commutator law in G2 is",_comm(x,y,M)[2] eq 2*L([x1,y1]);

x:=<x1,x2,x3>;y:=<y1,y2,y3>;z:=<z1,z2,z3>;M:=M3;
print "Associative law in G3 is",M(M(x,y),z) eq M(x,M(y,z));
print "Commutator law in G3 is",_comm(_comm(x,y,M),z,M)[3] eq 12*L([x1,y1,z1]);

x:=<x1,x2,x3,x4>;y:=<y1,y2,y3,y4>;z:=<z1,z2,z3,z4>;w:=<w1,w2,w3,w4>;M:=M4;
print "Associative law in G4 is",M(M(x,y),z) eq M(x,M(y,z));
print "Commutator law in G4 is",
  _comm(_comm(_comm(x,y,M),z,M),w,M)[4]  eq 24*L([x1,y1,z1,w1]);

